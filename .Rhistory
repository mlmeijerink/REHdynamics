)
# Order by actor id
attributes <- attributes[order(attributes$id),]
# Save
usethis::use_data(attributes, overwrite = TRUE)
library(REHdynamics)
rm(list=ls())
# Load data
con <- gzcon(url("http://www.sociopatterns.org/wp-content/uploads/2018/12/tij_InVS15.dat_.gz"))
txt <- readLines(con)
# Load data
con <- gzcon(url("http://www.sociopatterns.org/wp-content/uploads/2018/12/tij_InVS15.dat_.gz"))
txt <- readLines(con)
contacts <- read.csv(textConnection(txt), sep = " ", header = FALSE)
names(contacts) <- c("t", "i", "j")
head(contacts)
# Actors
data(attributes)
actors <- sort(attributes$id)
head(attributes)
# Load data
con <- gzcon(url("http://www.sociopatterns.org/wp-content/uploads/2018/12/metadata_InVS15.txt"))
txt <- readLines(con)
meta <- read.csv(textConnection(txt), sep = "\t", header = FALSE)
names(meta) <- c("i", "Di")
# Prepare as attributes object
attributes <- data.frame(
id = meta$i,
time = 0,
department = factor(meta$Di)
)
head(attributes)
# Save
usethis::use_data(attributes, overwrite = TRUE)
library(REHdynamics)
# Load data
con <- gzcon(url("http://www.sociopatterns.org/wp-content/uploads/2018/12/metadata_InVS15.txt"))
txt <- readLines(con)
meta <- read.csv(textConnection(txt), sep = "\t", header = FALSE)
names(meta) <- c("i", "Di")
# Prepare as attributes object
attributes <- data.frame(
id = meta$i,
time = 0,
department = factor(meta$Di)
)
rm(list=ls())
# Load data
con <- gzcon(url("http://www.sociopatterns.org/wp-content/uploads/2018/12/tij_InVS15.dat_.gz"))
txt <- readLines(con)
contacts <- read.csv(textConnection(txt), sep = " ", header = FALSE)
names(contacts) <- c("t", "i", "j")
# Actors
data(attributes)
actors <- sort(attributes$id)
head(attributes)
actors
head(contacts)
# Undirected contacts: Make sure actors are sorted within rows
contacts[,c(2,3)] <- t(apply(contacts[,c(2,3)], 1, sort))
head(contacts)
# Create a riskset
riskset <- t(combn(actors, 2))
head(riskset)
nrow(riskset)
# Match edge ID
contacts$edge <- prodlim::row.match(contacts[,c("i", "j")], riskset)
# Create a riskset
riskset <- data.frame(t(combn(actors, 2)))
# Match edge ID
contacts$edge <- prodlim::row.match(contacts[,c("i", "j")], riskset)
head(contacts)
riskset[22784,]
names(riskset) <- c("i", "j")
# Transform edges
onset <- terminus <- vector()
onset_time <- terminus_time <- vector()
# Transform edges
onset <- terminus <- vector()
onset_time <- terminus_time <- vector()
for(i in 1:nrow(contacts)) {
# Did the edge occur in the last 20 seconds? If not, onset = TRUE
last <- contacts[contacts$time == contacts$time[i]-20, ]
onset[i] <- ifelse(contacts$edge[i] %in% last$edge, FALSE, TRUE)
# Does the edge occur in the next 20 seconds? If not, terminus = TRUE
subs <- contacts[contacts$time == contacts$time[i]+20, ]
terminus[i] <- ifelse(contacts$edge[i] %in% subs$edge, FALSE, TRUE)
}
for(i in 1:nrow(contacts)) {
if(onset[i]) {
# Set onset time if onset is true
onset_time[i] <- contacts$time[i] - 20
} else {
# Determine onset time if onset is false
onset_time[i] <- contacts$time[max(which(contacts$time < contacts$time[i] &
contacts$edge == contacts$edge[i] & onset))] - 20
}
if(terminus[i]) {
# Determine terminus time if terminus is true
terminus_time[i] <- contacts$time[i]
} else {
# Determine terminus time if terminus is false
terminus_time[i] <- contacts$time[min(which(contacts$time > contacts$time[i] &
contacts$edge == contacts$edge[i] & terminus))]
}
}
for(i in 1:nrow(contacts)) {
if(onset[i]) {
# Set onset time if onset is true
onset_time[i] <- contacts$t[i] - 20
} else {
# Determine onset time if onset is false
onset_time[i] <- contacts$t[max(which(contacts$t < contacts$t[i] &
contacts$edge == contacts$edge[i] & onset))] - 20
}
if(terminus[i]) {
# Determine terminus time if terminus is true
terminus_time[i] <- contacts$t[i]
} else {
# Determine terminus time if terminus is false
terminus_time[i] <- contacts$t[min(which(contacts$t > contacts$t[i] &
contacts$edge == contacts$edge[i] & terminus))]
}
}
contacts$onset <- onset
contacts$terminus <- terminus
contacts$onset_time <- onset_time
contacts$terminus_time <- terminus_time
contacts$duration <- contacts$terminus_time - contacts$onset_time
# Collect in a relational event history
edges <- contacts[contacts$onset==TRUE,
c("t", "i", "j", "duration")]
rownames(edges) <- NULL
head(edges)
names(edges) <- c("time", "actor1", "actor2", "duration")
head(edges)
hist(edges$duration)
onset_time
# Load data
con <- gzcon(url("http://www.sociopatterns.org/wp-content/uploads/2018/12/tij_InVS15.dat_.gz"))
txt <- readLines(con)
contacts <- read.csv(textConnection(txt), sep = " ", header = FALSE)
names(contacts) <- c("t", "i", "j")
# Actors
data(attributes)
actors <- sort(attributes$id)
# Undirected contacts: Make sure actors are sorted within rows
contacts[,c(2,3)] <- t(apply(contacts[,c(2,3)], 1, sort))
# Create a riskset
riskset <- data.frame(t(combn(actors, 2)))
names(riskset) <- c("i", "j")
# Match edge ID
contacts$edge <- prodlim::row.match(contacts[,c("i", "j")], riskset)
# Transform edges
onset <- terminus <- vector()
onset_time <- terminus_time <- vector()
for(i in 1:nrow(contacts)) {
# Did the edge occur in the last 20 seconds? If not, onset = TRUE
last <- contacts[contacts$time == contacts$time[i]-20, ]
onset[i] <- ifelse(contacts$edge[i] %in% last$edge, FALSE, TRUE)
# Does the edge occur in the next 20 seconds? If not, terminus = TRUE
subs <- contacts[contacts$time == contacts$time[i]+20, ]
terminus[i] <- ifelse(contacts$edge[i] %in% subs$edge, FALSE, TRUE)
}
for(i in 1:nrow(contacts)) {
if(onset[i]) {
# Set onset time if onset is true
onset_time[i] <- contacts$t[i] - 20
} else {
# Determine onset time if onset is false
onset_time[i] <- contacts$t[max(which(contacts$t < contacts$t[i] &
contacts$edge == contacts$edge[i] & onset))] - 20
}
if(terminus[i]) {
# Determine terminus time if terminus is true
terminus_time[i] <- contacts$t[i]
} else {
# Determine terminus time if terminus is false
terminus_time[i] <- contacts$t[min(which(contacts$t > contacts$t[i] &
contacts$edge == contacts$edge[i] & terminus))]
}
}
contacts$onset <- onset
contacts$terminus <- terminus
contacts$onset_time <- onset_time
contacts$terminus_time <- terminus_time
contacts$duration <- contacts$terminus_time - contacts$onset_time
# Collect in a relational event history
edges <- contacts[contacts$onset==TRUE,
c("t", "i", "j", "duration")]
rownames(edges) <- NULL
names(edges) <- c("time", "actor1", "actor2", "duration")
hist(edges$duration)
head(contacts)
# Load data
con <- gzcon(url("http://www.sociopatterns.org/wp-content/uploads/2018/12/tij_InVS15.dat_.gz"))
txt <- readLines(con)
contacts <- read.csv(textConnection(txt), sep = " ", header = FALSE)
names(contacts) <- c("t", "i", "j")
# Actors
data(attributes)
actors <- sort(attributes$id)
# Undirected contacts: Make sure actors are sorted within rows
contacts[,c(2,3)] <- t(apply(contacts[,c(2,3)], 1, sort))
# Create a riskset
riskset <- data.frame(t(combn(actors, 2)))
names(riskset) <- c("i", "j")
# Match edge ID
contacts$edge <- prodlim::row.match(contacts[,c("i", "j")], riskset)
# Transform edges
onset <- terminus <- vector()
onset_time <- terminus_time <- vector()
for(i in 1:nrow(contacts)) {
# Did the edge occur in the last 20 seconds? If not, onset = TRUE
last <- contacts[contacts$t == contacts$t[i]-20, ]
onset[i] <- ifelse(contacts$edge[i] %in% last$edge, FALSE, TRUE)
# Does the edge occur in the next 20 seconds? If not, terminus = TRUE
subs <- contacts[contacts$t == contacts$t[i]+20, ]
terminus[i] <- ifelse(contacts$edge[i] %in% subs$edge, FALSE, TRUE)
}
for(i in 1:nrow(contacts)) {
if(onset[i]) {
# Set onset time if onset is true
onset_time[i] <- contacts$t[i] - 20
} else {
# Determine onset time if onset is false
onset_time[i] <- contacts$t[max(which(contacts$t < contacts$t[i] &
contacts$edge == contacts$edge[i] & onset))] - 20
}
if(terminus[i]) {
# Determine terminus time if terminus is true
terminus_time[i] <- contacts$t[i]
} else {
# Determine terminus time if terminus is false
terminus_time[i] <- contacts$t[min(which(contacts$t > contacts$t[i] &
contacts$edge == contacts$edge[i] & terminus))]
}
}
contacts$onset <- onset
contacts$terminus <- terminus
contacts$onset_time <- onset_time
contacts$terminus_time <- terminus_time
contacts$duration <- contacts$terminus_time - contacts$onset_time
# Collect in a relational event history
edges <- contacts[contacts$onset==TRUE,
c("t", "i", "j", "duration")]
rownames(edges) <- NULL
names(edges) <- c("time", "actor1", "actor2", "duration")
hist(edges$duration)
# Artificial Date-Time (start on ``a'' Monday in January, here set to the
# first Monday)
edges$date <- as.POSIXct(edges$time, origin = "2015-01-04 23:00:00",
tz = "Europe/Paris")
head(edges)
library(lubridate)
days <- unique(day(edges$date))
hours <- unique(hour(edges$date))
days
hours
nmat <- matrix(NA, nrow = length(hours), ncol = length(days))
nmat <- matrix(NA, nrow = length(hours), ncol = length(days))
for(h in 1:nrow(nmat)) {
for(d in 1:ncol(nmat)) {
nmat[h,d] <- sum(day(edges$date) == days[d] & hour(edges$date) == hours[h])
}
}
rownames(nmat) <- hours
colnames(nmat) <- days
nmat
# Artificial Date-Time (start on ``a'' Monday in January, here set to the
# first Monday)
edges$date <- as.POSIXct(edges$time, origin = "2015-01-04 24:00:00",
tz = "Europe/Paris")
days <- unique(day(edges$date))
hours <- unique(hour(edges$date))
nmat <- matrix(NA, nrow = length(hours), ncol = length(days))
for(h in 1:nrow(nmat)) {
for(d in 1:ncol(nmat)) {
nmat[h,d] <- sum(day(edges$date) == days[d] & hour(edges$date) == hours[h])
}
}
rownames(nmat) <- hours
colnames(nmat) <- days
nmat
# Artificial Date-Time (start on ``a'' Monday in January, here set to the
# first Monday)
edges$date <- as.POSIXct(edges$time, origin = "2015-01-04 23:00:00",
tz = "Europe/Paris")
# Adapt inter-event time to remove idle periods from the data
days <- unique(day(events$date))
# Adapt inter-event time to remove idle periods from the data
days <- unique(lubridate::day(edges$date))
dates <- c(
as.POSIXct("2015-01-06 08:00:00"),
as.POSIXct("2015-01-07 08:00:00"),
as.POSIXct("2015-01-08 08:00:00"),
as.POSIXct("2015-01-09 08:00:00"),
as.POSIXct("2015-01-12 08:00:00"),
as.POSIXct("2015-01-13 08:00:00"),
as.POSIXct("2015-01-14 08:00:00"),
as.POSIXct("2015-01-15 08:00:00"),
as.POSIXct("2015-01-16 08:00:00")
)
events$rtime <- events$date - as.POSIXct("2015-01-05 08:00:00")
edges$rtime <- edges$date - as.POSIXct("2015-01-05 08:00:00")
# Adapt inter-event time to remove idle periods from the data
days <- unique(lubridate::day(edges$date))
dates <- c(
as.POSIXct("2015-01-06 08:00:00"),
as.POSIXct("2015-01-07 08:00:00"),
as.POSIXct("2015-01-08 08:00:00"),
as.POSIXct("2015-01-09 08:00:00"),
as.POSIXct("2015-01-12 08:00:00"),
as.POSIXct("2015-01-13 08:00:00"),
as.POSIXct("2015-01-14 08:00:00"),
as.POSIXct("2015-01-15 08:00:00"),
as.POSIXct("2015-01-16 08:00:00")
)
edges$rtime <- edges$date - as.POSIXct("2015-01-05 08:00:00")
for(d in 1:length(days)) {
# Day starts at eight
aftereight <- edges$date[min(which(day(edges$date) == days[d + 1]))] -
dates[d]
# Day ends after the last event
lastevent <- edges$rtime[max(which(day(edges$date) == days[d]))]
# Difference
subtract <- edges$rtime[min(which(day(edges$date) == days[d + 1]))] -
lastevent - aftereight
# Adapt
edges$rtime[day(edges$date) > days[d]] <-
edges$rtime[day(edges$date) > days[d]] - subtract
}
edges$rtime <- as.numeric(edges$rtime)
hist(edges$rtime)
hist(edges$date)
hist(edges$date, breaks = hours)
hist(edges$date, breaks = "hours")
hist(edges$rtime, breaks = 100)
head(edges)
# Rearrange columns
edges <- edges[,c("rtime", "actor1", "actor2", "duration", "date")]
colnames(edges)[1] <- "time"
head(edges)
# Timing between edges
prep <- remify::reh(edgelist = edges, actors = attributes$id, directed = FALSE,
origin = 0, model = "tie")
edges$time <- cumsum(prep$intereventTime)
hist(edges$time, breaks = 100)
attributes$department
library(remstats)
same("department", attributes)
usethis::use_data(edges, overwrite = TRUE)
library(REHdynamics)
rm(list=ls())
library(REHdynamics)
head(edges)
head(attributes)
usethis::use_data_raw("edgesS")
usethis::use_data_raw("attributesS")
# Load data
data(edges)
data(attributes)
# Sample
set.seed(123)
actors <- sample(attributes$id, size = 30)
usethis::use_data_raw("covar")
## code to prepare `covar` dataset goes here
# Generate the actors and their exogenous information for the
# generated datasets
set.seed(27613)
covar <- data.frame(id = 1:30, time = 0, z = rnorm(n = 30))
usethis::use_data(covar, overwrite = TRUE)
library(REHdynamics)
usethis::use_data_raw("constant")
usethis::use_data_raw("param")
param <- list(
constant = list(
"baseline" = -8,
"z_send"= 0.2,
"z_difference" = -0.2,
"activity" = 0.1,
"inertia" = 0.1,
"transitivity" = 0.2
),
cyclic = list(
"baseline" = function(t) {
0.5 * sin(((2*pi)/10000)*t) + -8
},
"z_send" = function(t) {
0.1 * sin(((2*pi)/10000)*t) + 0.2
},
"z_difference" = function(t) {
0.1 * sin(((2*pi)/10000)*t) - 0.2
},
"activity" = function(t) {
0.05 * sin(((2*pi)/10000)*t) + 0.1
},
"inertia" = function(t) {
0.05 * cos(((2*pi)/10000)*t) + 0.1
},
"transitivity" = function(t) {
0.1 * sin(((2*pi)/10000)*t) + 0.2
}
),
gradual = list(
"baseline" = function(t) {
1 / (1 + exp(-0.001 * (t - 12500))) - 8.5
},
"z_send" = function(t) {
0.2 / (1 + exp(-0.001 * (t - 12500))) + 0.1
},
"z_difference" = function(t) {
0.2 / (1 + exp(-0.001 * (t - 12500))) - 0.3
},
"activity" = function(t) {
0.1 / (1 + exp(-0.001 * (t - 12500))) + 0.05
},
"inertia" = function(t) {
0.1 / (1 + exp(-0.001 * (t - 12500))) + 0.05
},
"transitivity" = function(t) {
0.2 / (1 + exp(-0.001 * (t - 12500))) + 0.1
}
),
mixed = list(
"baseline" = function(t) {
0.5 * sin(((2*pi)/10000)*t) + -8
},
"z_send"= 0.2,
"z_difference" = -0.2,
"activity" = function(t) {
0.05 * sin(((2*pi)/10000)*t) + 0.1
},
"inertia" = function(t) {
0.1 / (1 + exp(-0.001 * (t - 12500))) + 0.05
},
"transitivity" = function(t) {
0.2 / (1 + exp(-0.001 * (t - 12500))) + 0.1
}
))
param
param[[1]]
usethis::use_data(param, overwrite = TRUE)
library(REHdynamics)
# Load parameters
data(param, package = "REHdynamics")
param <- param$constant
# Model
formula <- ~
remulate::baseline(param$baseline) +
remulate::send(param$z_send, "z", covar) +
remulate::difference(param$z_difference, "z", covar) +
remulate::outdegreeSender(param$activity, scaling = "std") +
remulate::inertia(param$inertia, scaling = "std") +
remulate::otp(param$transitivity, scaling = "std")
# Load covar
data(covar, package = "REHdynamics")
# Test
set.seed(27613)
sytem.time(test <- remulate::remulateTie(effects = formula, actors = covar$id,
time = 50000, events = 10000)$edgelist)
system.time(test <- remulate::remulateTie(effects = formula, actors = covar$id,
time = 50000, events = 10000)$edgelist)
800/60
test[1,]
load("C:/Users/mlbosman/surfdrive/Documents/Projects/2. Network dynamics/New_analysis/Data/constant.RData")
test[1,]
constant <- data
usethis::use_data(constant, overwrite = TRUE)
usethis::use_data_raw("cyclic")
rm(list=ls())
## code to prepare `cyclic` dataset goes here
library(remulate)  # devtools::install_github("TilburgNetworkGroup/remulate")
# Load parameters
data(param, package = "REHdynamics")
param <- param$cyclic
# Model
formula <- ~
remulate::baseline(param$baseline) +
remulate::send(param$z_send, "z", covar) +
remulate::difference(param$z_difference, "z", covar) +
remulate::outdegreeSender(param$activity, scaling = "std") +
remulate::inertia(param$inertia, scaling = "std") +
remulate::otp(param$transitivity, scaling = "std")
# Load covar
data(covar, package = "REHdynamics")
# Generate data
cyclic <- list()
remulate::remulateTie(effects = formula, actors = covar$id,
time = 50000, events = 10)$edgelist
set.seed(27613)
remulate::remulateTie(effects = formula, actors = covar$id,
time = 50000, events = 10)$edgelist
load("C:/Users/mlbosman/surfdrive/Documents/Projects/2. Network dynamics/New_analysis/Data/cyclic.RData")
head(data[[1]])
cyclic <- data
usethis::use_data_raw("gradual")
load("C:/Users/mlbosman/surfdrive/Documents/Projects/2. Network dynamics/New_analysis/Data/gradual.RData")
gradual <- data
usethis::use_data(gradual, overwrite = TRUE)
usethis::use_data_raw("mixed")
load("C:/Users/mlbosman/surfdrive/Documents/Projects/2. Network dynamics/New_analysis/Data/mixed.RData")
mixed <- data
usethis::use_data(mixed, overwrite = TRUE)
library(REHdynamics)
rm(list=ls())
library(REHdynamics)
load(constant)
data(constant)
head(constant[[1]])
data(param)
param$constant
